<script type="text/javascript" async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
**计算机图形学期末复习整理 by Cinkye**
Inspired by [@Pangxiaox](https://github.com/Pangxiaox)

本文所有知识点完全由**个人感觉**从课本和PPT中提取和整理，**不代表其它任何人和组织意见**。如有遗漏，大家一起挂科（，祝大家考试好运！
# 第二章
1. 3D Model Coordination -> *Modeling Transformation* -> 3D World Coordination -> *Viewing Transformation* -> 3D Eye Coordination -> *Clipping* -> 3D Eye Coordination -> *Projection* -> 2D Eye Coordination -> *Window to viewport transfromation* -> 2D Screen Coordination
2. 上述过程中，**前三个变换**由 vertex shader 完成，**最后一个**由 fragment shader 完成。
3. GLSL shaders
Vertex shader -> Tessellation Control Shader -> Tessellation Evatuation Shader -> Geometry Shader -> Peimitive Setup -> Clipping -> Rasterization -> Fragment Shader
4. 一个简单的GLUT程序执行顺序
- 初始化GLUT glutInit()
- 初始化窗口位置和大小
- init()函数和显示、鼠标等回调函数定义
- 进入主循环 glutMainLoop()
5. Primitives
**（看书里的图会更好，英文第六版P88，PPT第二章P35）**
确定顶点构成的形状
- GL_POINTS 点
- GL_LINES 线段 以（v0，v1）（v2，v3）（v3，v4）的形式连接起来
- GL_LINE_STRIP 所有顶点连成一条折线 （v0, v1）（v1，v2）（v2，v3）
- GL_LINE_LOOP 与上一个类似，但连成一个环
- GL_TRIANGLES 三角形 （0，1，2）（3，4，5）
- GL_TRIANGLE_STRIP 三角形（0，1，2）（1，2，3）（2，3，4）
- GL_TRIANGLE_FAN 三角形（0，1，2）（0，2，3）（0，3，4）
6. OpenGL只显示三角形：简单（simple）、凸（Convex）多边形、在同一平面上
7. 代码大致流程
- 创建并绑定VAO
- 创建并绑定VBO
- 将数据缓存到VBO中
- 配置顶点属性指针（指定数据在VBO中的格式）
- 载入并使用shader
- 画图
8. **VAO 顶点数组对象**
确定VBO中的数据应该怎样处理
存储顶点属性指针
9. **VBO 顶点缓存对象**
向GPU中传输大块数据
当前与VAO绑定的数据会被传到GPU中

# 第三章
10. 反射向量（应该不会考吧）
N为法向量，P为入射向量的-1倍
Q = 2N（N·P）-P
11. 直线方程
- 一般式： Ax + By + C = 0
- 点斜式： y = kx + b
- 截距式： y = y' + k(x - x')
- (y - y') / (y'' - y') = (x - x') / (x'' - x')
- 参数方程：
  x = x' + t(x'' - x') 
  y = y' + t(y'' - y') 
  z = z' + t(z'' - z') 
12. 平面方程和法向量
法向量N(A, B, C) = (p - p') × (p'' - p)
- 一般式：Ax + By +Cz +D = 0
- (A, B, C) · (x - x', y - y', z - z') = 0
**判断点在面的正面还是反面：**
将点的坐标代入平面方程，大于0为正面，小于0为反面。
**判断直线与平面的交点：**
用参数方程代入，求t
**求点到平面距离**：
找平面上任意一点，作与目标点的向量，再点乘单位法向量
13. 基本变换
- 平移(Translation)：P' = P + T
- 缩放(Scaling)：P' = S * P
- 旋转(Rotation)：P' = R * P
T = (x, y, z)
S = $$
 \left\{
 \begin{matrix}
   x & 0 & 0 \\\\
   0 & y & 0 \\\\
   0 & 0 & z
  \end{matrix}
  \right\} 
$$
R = $$
 \left\{
 \begin{matrix}
   1 & 0 & 0 \\\\
   0 & cosθ & -sinθ \\\\
   0 & sinθ & cosθ
  \end{matrix}
  \right\}
$$
用齐次坐标把他们组合起来：
T = $$
 \left\{
 \begin{matrix}
   0 & 0 & 0 & x\\\\
   0 & 0 & 0 & y\\\\
   0 & 0 & 0 & z\\\\
   0 & 0 & 0 & 1
  \end{matrix}
  \right\} 
$$
S = $$
 \left\{
 \begin{matrix}
   x & 0 & 0 & 0\\\\
   0 & y & 0 & 0\\\\
   0 & 0 & z & 0\\\\
   0 & 0 & 0 & 1
  \end{matrix}
  \right\} 
$$
R = $$
 \left\{
 \begin{matrix}
   1 & 0 & 0 & 0\\\\
   0 & cosθ & -sinθ & 0\\\\
   0 & sinθ & cosθ & 0\\\\
   0 & 0 & 0 & 1
  \end{matrix}
  \right\} 
$$
上述三种变换都是由变换矩阵**左乘**原矩阵
14. Shear 错切
sh<sub>x</sub> = tanθ, 即 y = 1 在 x 方向的距离。
$$
 \left\{
 \begin{matrix}
   1 & shx & 0\\\\
   0 & 1 & 0\\\\
   0 & 0 & 1\\\\
  \end{matrix}
  \right\} 
$$
# 第四章
15. 两种投影的view volume计算
- 透视投影：
x = ± (right - left) / (-2 * near)
y = ± (top - bottom) / (-2 * near)
z<sub>min</sub> = -near
z<sub>max</sub> = -far
- 正交投影
x = left
x = right
y = top 
y = bottom
z<sub>min</sub> = -near
z<sub>max</sub> = -far
16. **Modelview Duality**
可以通过移动viewer或model达到同样的效果，两者的变换矩阵互为逆矩阵。
**移动viewer**: LookAt(eye,at,up)
先用 eye 与 at 算出 z 轴，再用up 和 z 轴算出 x 轴，然后用 z 轴和 x 轴算出 y 轴，最后将坐标轴原点平移到 eye 处。
**移动model**: 
translatef(), rotatef(), scalef()三个函数
17. Viewport 视口
窗口中的画图区，默认大小为整个窗口。
视口可以有一个，也可以有多个
Window2Viewport变换：等同于沿一个固定点作scale
先将window平移回坐标原点，作scale，再移到viewport位置
如果window和viewport的纵横比不一样，作scale式会导致变形，此时应该将缩放系数统一为S<sub>x</sub>, S<sub>y</sub>中两者较小的一个，空出的部分用背景色填充。
18. Viewing Transformations
Viewing：确定摄像机位置和方向
Modeling：在场景中移动模型
Modelview：描述modelview duality
Projection：将3D模型投影到2D窗口
Viewport：将窗口坐标转换到视口坐标
# 第五章 光照与阴影
19. Lighting model （应该不考吧） 
Local lighting model: 全部光来自场景内定义的光源。
Global lighting model: 所有表面反射的光会影响到其它表面。
20. **光的组成** 
- Ambient 环境光
A  = L<sub>0</sub> + Σ<sub>light</sub>( L<sub>A</sub> * C<sub>A</sub>)
其中L<sub>0</sub>为整体光亮度，L<sub>A</sub>为环境光亮度，C<sub>A</sub>为材质。
**不关心光源位置、观察者位置和表面法向量等。**
- Diffuse 漫反射
D = Σ<sub>lights</sub> L<sub>D</sub> * C<sub>D</sub> * （L · N）
**与物体表面法向量与光向量的夹角有关**
- Specular 镜面反射
S = Σ<sub>lights</sub> L<sub>D</sub> * C<sub>D</sub> * （V · R）<sup>K</sup>
**与眼睛向量与反射光向量的夹角有关**
K 是一个经验常量，数值越大，光斑越小越亮。
21. 计算光照所需要的向量 
- 入射光向量
- 反射光向量
- **法向量**
顶点的法向量可以由顶点处的两个向量叉乘求得。
平面的法向量可由组成平面的各个顶点的求平均值得到。
- 眼睛向量
22. 材质 
由三个三元组组成，分别表示三种光的RGB值。
23. 光源 
- 点光源 (x, y, z, 1)<sup>T</sup>
在同一平面的不同位置，光的方向不同，但法向量相同。
- 平行光 (x, y, z, 0)<sup>T</sup>
在同一平面的不同位置，光的方向相同，法向量也相同。
- 聚光灯 spotlight
包括方向、角度、位置、距离等参数。
24. Light Attenuation 光的衰减 
理论值：1 / d²
实际使用：1 / (a + bd + cd²)
25. Shading 计算物体每个像素的颜色
- Constant (Flat) Shading 
根据**一个顶点**计算整个多边形的颜色。
- Gouraud (Smooth) Shading
利用每个顶点的法向量计算顶点的颜色，利用中间插值计算其它点的**颜色**
Increment Computing *作业题*
I<sub>P2</sub> = (1 - t<sub>2</sub>) * I<sub>Q</sub> + t<sub>2</sub> * I<sub>R</sub>
I<sub>P1</sub> = (1 - t<sub>1</sub>) * I<sub>Q</sub> + t<sub>1</sub> * I<sub>R</sub>
I<sub>P2</sub> = I<sub>P1</sub> + (I<sub>R</sub> - I<sub>Q</sub>) (t<sub>2</sub> - t<sub>1</sub>) = I<sub>P1</sub> + ΔI<sub>RQ</sub> * Δt
- Phong Shading
插值获得每个像素对应的**法向量**，并利用这些法向量计算颜色。
Increment Computing 与 Gouraud 类似。
26. 
光(LR, LG, LB)与材质(MR, MG, MB)作用 => (LR*MR, LG*MG, LB*MB)   **相乘**
两个光 (R1, G1, B1) 与 (R2, G2, B2)的叠加 => (R1+R2, G1+G2, B1+B2). **相加**
**漫反射**提供了大部分物体的曲率和深度信息
环境光反射率一般与漫反射率相同
27.Transparency 
由RGBA的最后一位——Alpha通道确定（1为不透明，0为完全透明）
# 第六章 Rendering 
28. **Cohen-Sutherland线段裁剪算法** 
**判断是否需要裁剪：使用四位Outcodes(TBRL分别表示上下左右)，每一位对应一个边界。每一条线把整个平面分为两部分，包含有效区域的一边对应的编码为0，另一边为1。对应的编码如下图所示**

| 1001 | 1000 | 1010 |
| :-------------: |:-------------:| :-----:|
| 0001 | 0000 | 0010 |
| 0101 | 0100 | 0110 |

**两个端点按位或为0：完全保留**
**两个端点按位与不为0：完全放弃**
**其它：裁剪线段**
由于裁切窗口相对整个场景较小，大部分的线段都在窗口外，*效率较低*

29. **梁友栋-Barsky线段裁剪算法** 
基于线段的参数方程
x = x<sub>1</sub> + t*(x<sub>2</sub> - x<sub>1</sub>)          y = y<sub>1</sub> + t*(y<sub>2</sub> - y<sub>1</sub>)
0 <= t <= 1 
**始边:靠近s1的窗边界线** 
**终边:靠近s2的窗边界线**
**设t<sub>1</sub>′, t<sub>1</sub>″为s<sub>1</sub>s<sub>2</sub>与两个始边的交点参数，t<sub>2</sub>′, t<sub>2</sub>″为s<sub>1</sub>s<sub>2</sub>与两个终边的交点参数，t<sub>2</sub> = min{t<sub>2</sub>′, t<sub>2</sub>″, 0} **
**若t<sub>1</sub> < t<sub>2</sub>时，t∈[t<sub>1</sub>, t<sub>2</sub>]部分为裁剪好的可见部分。**
优点：简单，只需要一个参数值t，而且可轻松地扩展到3D。

30. 多边形裁剪算法 
思想：用四个窗边界线依次裁剪多边形的所有边，得到一个裁剪后的顶点序列

31. Rasterization 
计算线段对应的像素点
- **DDA Algorithm**：根据斜率确定像素点
斜率m绝对值小于1时：
x每次递增1，y每次递增m（取整）
斜率m绝对值大于1时：
y每次递增1，x每次递增1/m（取整）
- **Bresenham Algorithm**
与DDA类似，但用直接代入计算代替递增，并用四舍五入代替取整
- 计算多边形：逐行扫描
用一个链表数组记录每一行的起始x坐标和结束x坐标
步骤：计算每一根扫描线与多边形的边的交点，然后把所有交点按x坐标递增顺序来排序
特殊情况： 扫描线与多边形的顶点相交 
如果顶点的两条相邻边位于扫描线的一边，则交点算两个。
如果顶点的两条相邻边位于扫描线的两边，则交点算一个。

32. Hidden-Surface Removal 
- z-buffer Algorithm
深度缓存与帧缓存一致
- The painter‘s Algorithm
将所有多边形按深度排序
从后往前渲染多边形

33. Antialiasing 抗锯齿 
有颜色的部分和没有颜色的部分差异太大，形成明显的锯齿(jaggle)
**解决方法：按照多边形与像素点相交部分在像素点中占比来混合颜色形成过渡**
设占比为α，则颜色为：**α \* 多边形颜色 + （1 - α） \* 背景颜色**
GL中启用：glEnable(GL_LINE_SMOOTH)
glEnable(GL_POLYGON_SMOOTH)
问题：小的多边形被直接忽略；一个像素点的颜色可能由多个多边形确定

34. 颜色模型 
RGB：常用于屏幕
CMYK：常用于打印机
HSV：色调、饱和度、值，常用于艺术创作
HLS：色调、亮度、饱和度，常用于艺术创作