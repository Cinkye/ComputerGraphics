**计算机图形学期末复习整理 by Cinkye**
Inspired by [@Pangxiaox](https://github.com/Pangxiaox)

本文所有知识点完全由**个人感觉**从课本和PPT中提取和整理，**不代表其它任何人和组织意见**。如有遗漏，大家一起挂科（，祝大家考试好运！
# 第二章
1. 3D Model Coordination -> *Modeling Transformation* -> 3D World Coordination -> *Viewing Transformation* -> 3D Eye Coordination -> *Clipping* -> 3D Eye Coordination -> *Projection* -> 2D Eye Coordination -> *Window to viewport transfromation* -> 2D Screen Coordination
2. 上述过程中，**前三个变换**由 vertex shader 完成，**最后一个**由 fragment shader 完成。
3. GLSL shaders
Vertex shader -> Tessellation Control Shader -> Tessellation Evatuation Shader -> Geometry Shader -> Peimitive Setup -> Clipping -> Rasterization -> Fragment Shader
4. 一个简单的GLUT程序执行顺序
- 初始化GLUT glutInit()
- 初始化窗口位置和大小
- init()函数和显示、鼠标等回调函数定义
- 进入主循环 glutMainLoop()
5. Primitives
**（看书里的图会更好，英文第六版P88，PPT第二章P35）**
确定顶点构成的形状
- GL_POINTS 点
- GL_LINES 线段 以（v0，v1）（v2，v3）（v3，v4）的形式连接起来
- GL_LINE_STRIP 所有顶点连成一条折线 （v0, v1）（v1，v2）（v2，v3）
- GL_LINE_LOOP 与上一个类似，但连成一个环
- GL_TRIANGLES 三角形 （0，1，2）（3，4，5）
- GL_TRIANGLE_STRIP 三角形（0，1，2）（1，2，3）（2，3，4）
- GL_TRIANGLE_FAN 三角形（0，1，2）（0，2，3）（0，3，4）
6. OpenGL只显示三角形：简单（simple）、凸（Convex）多边形、在同一平面上
7. 代码大致流程
- 创建并绑定VAO
- 创建并绑定VBO
- 将数据缓存到VBO中
- 配置顶点属性指针（指定数据在VBO中的格式）
- 载入并使用shader
- 画图
8. **VAO 顶点数组对象**
确定VBO中的数据应该怎样处理
存储顶点属性指针
9. **VBO 顶点缓存对象**
向GPU中传输大块数据
当前与VAO绑定的数据会被传到GPU中

# 第三章
10. 反射向量（应该不会考吧）
N为法向量，P为入射向量的-1倍
Q = 2N（N·P）-P
11. 直线方程
- 一般式： Ax + By + C = 0
- 点斜式： y = kx + b
- 截距式： y = y' + k(x - x')
- (y - y') / (y'' - y') = (x - x') / (x'' - x')
- 参数方程：
  x = x' + t(x'' - x') 
  y = y' + t(y'' - y') 
  z = z' + t(z'' - z') 
12. 平面方程和法向量
法向量N(A, B, C) = (p - p') × (p'' - p)
- 一般式：Ax + By +Cz +D = 0
- (A, B, C) · (x - x', y - y', z - z') = 0
**判断点在面的正面还是反面：**
将点的坐标代入平面方程，大于0为正面，小于0为反面。
**判断直线与平面的交点：**
用参数方程代入，求t
**求点到平面距离**：
找平面上任意一点，作与目标点的向量，再点乘单位法向量
13. 基本变换
- 平移(Translation)：P' = P + T
- 缩放(Scaling)：P' = S * P
- 旋转(Rotation)：P' = R * P
T = (x, y, z)
S = $$
 \left\{
 \begin{matrix}
   x & 0 & 0 \\\\
   0 & y & 0 \\\\
   0 & 0 & z
  \end{matrix}
  \right\} 
$$
R = $$
 \left\{
 \begin{matrix}
   1 & 0 & 0 \\\\
   0 & cosθ & -sinθ \\\\
   0 & sinθ & cosθ
  \end{matrix}
  \right\}
$$
用齐次坐标把他们组合起来：
T = $$
 \left\{
 \begin{matrix}
   0 & 0 & 0 & x\\\\
   0 & 0 & 0 & y\\\\
   0 & 0 & 0 & z\\\\
   0 & 0 & 0 & 1
  \end{matrix}
  \right\} 
$$
S = $$
 \left\{
 \begin{matrix}
   x & 0 & 0 & 0\\\\
   0 & y & 0 & 0\\\\
   0 & 0 & z & 0\\\\
   0 & 0 & 0 & 1
  \end{matrix}
  \right\} 
$$
R = $$
 \left\{
 \begin{matrix}
   1 & 0 & 0 & 0\\\\
   0 & cosθ & -sinθ & 0\\\\
   0 & sinθ & cosθ & 0\\\\
   0 & 0 & 0 & 1
  \end{matrix}
  \right\} 
$$
上述三种变换都是由变换矩阵**左乘**原矩阵
14. Shear 错切
sh<sub>x</sub> = tanθ, 即 y = 1 在 x 方向的距离。
$$
 \left\{
 \begin{matrix}
   1 & shx & 0\\\\
   0 & 1 & 0\\\\
   0 & 0 & 1\\\\
  \end{matrix}
  \right\} 
$$
# 第四章
15. 两种投影的view volume计算
- 透视投影：
x = ± (right - left) / (-2 * near)
y = ± (top - bottom) / (-2 * near)
z<sub>min</sub> = -near
z<sub>max</sub> = -far
- 正交投影
x = left
x = right
y = top 
y = bottom
z<sub>min</sub> = -near
z<sub>max</sub> = -far
16. Modelview Duality
可以通过移动viewer或model达到同样的效果，两者的变换矩阵互为逆矩阵。
移动viewer: LookAt(eye,at,up)
先用 eye 与 at 算出 z 轴，再用up 和 z 轴算出 x 轴，最后用 z 轴和 x 轴算出 y 轴。