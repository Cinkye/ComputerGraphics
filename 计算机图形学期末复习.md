**计算机图形学期末复习整理 by Cinkye**
Inspired by [@Pangxiaox](https://github.com/Pangxiaox)

本文所有知识点完全由**个人感觉**从课本和PPT中提取和整理，**不代表其它任何人和组织意见**。如有遗漏，大家一起挂科（，祝大家考试好运！
# 第二章
1. 3D Model Coordination -> *Modeling Transformation* -> 3D World Coordination -> *Viewing Transformation* -> 3D Eye Coordination -> *Clipping* -> 3D Eye Coordination -> *Projection* -> 2D Eye Coordination -> *Window to viewport transfromation* -> 2D Screen Coordination
2. 上述过程中，**前三个变换**由 vertex shader 完成，**最后一个**由 fragment shader 完成。
3. GLSL shaders
Vertex shader -> Tessellation Control Shader -> Tessellation Evatuation Shader -> Geometry Shader -> Peimitive Setup -> Clipping -> Rasterization -> Fragment Shader
4. 一个简单的GLUT程序执行顺序
- 初始化GLUT glutInit()
- 初始化窗口位置和大小
- init()函数和显示、鼠标等回调函数定义
- 进入主循环 glutMainLoop()
5. Primitives
**（看书里的图会更好，英文第六版P88，PPT第二章P35）**
确定顶点构成的形状
- GL_POINTS 点
- GL_LINES 线段 以（v0，v1）（v2，v3）（v3，v4）的形式连接起来
- GL_LINE_STRIP 所有顶点连成一条折线 （v0, v1）（v1，v2）（v2，v3）
- GL_LINE_LOOP 与上一个类似，但连成一个环
- GL_TRIANGLES 三角形 （0，1，2）（3，4，5）
- GL_TRIANGLE_STRIP 三角形（0，1，2）（1，2，3）（2，3，4）
- GL_TRIANGLE_FAN 三角形（0，1，2）（0，2，3）（0，3，4）
6. OpenGL只显示三角形：简单（simple）、凸（Convex）多边形、在同一平面上
7. 代码大致流程
- 创建并绑定VAO
- 创建并绑定VBO
- 将数据缓存到VBO中
- 配置顶点属性指针（指定数据在VBO中的格式）
- 载入并使用shader
- 画图
8. **VAO 顶点数组对象**
确定VBO中的数据应该怎样处理
存储顶点属性指针
9. **VBO 顶点缓存对象**
向GPU中传输大块数据
当前与VAO绑定的数据会被传到GPU中

# 第三章
10. 反射向量（应该不会考吧）
N为法向量，P为入射向量的-1倍
Q = 2N（N·P）-P
11. 直线方程
- 一般式： Ax + By + C = 0
- 点斜式： y = kx + b
- 截距式： y = y' + k(x - x')
- (y - y') / (y'' - y') = (x - x') / (x'' - x')
- 参数方程：
  x = x' + t(x'' - x') 
  y = y' + t(y'' - y') 
  z = z' + t(z'' - z') 
12. 平面方程和法向量
法向量N(A, B, C) = (p - p') × (p'' - p)
- 一般式：Ax + By +Cz +D = 0
- (A, B, C) · (x - x', y - y', z - z') = 0
**判断点在面的正面还是反面：**
将点的坐标代入平面方程，大于0为正面，小于0为反面。
**判断直线与平面的交点：**
用参数方程代入，求t
**求点到平面距离**：
找平面上任意一点，作与目标点的向量，再点乘单位法向量
13. 基本变换
- 平移(Translation)：P' = P + T
- 缩放(Scaling)：P' = S * P
- 旋转(Rotation)：P' = R * P
T = (x, y, z)
S = $$
 \left\{
 \begin{matrix}
   x & 0 & 0 \\\\
   0 & y & 0 \\\\
   0 & 0 & z
  \end{matrix}
  \right\} 
$$
R = $$
 \left\{
 \begin{matrix}
   1 & 0 & 0 \\\\
   0 & cosθ & -sinθ \\\\
   0 & sinθ & cosθ
  \end{matrix}
  \right\}
$$
用齐次坐标把他们组合起来：
T = $$
 \left\{
 \begin{matrix}
   0 & 0 & 0 & x\\\\
   0 & 0 & 0 & y\\\\
   0 & 0 & 0 & z\\\\
   0 & 0 & 0 & 1
  \end{matrix}
  \right\} 
$$
S = $$
 \left\{
 \begin{matrix}
   x & 0 & 0 & 0\\\\
   0 & y & 0 & 0\\\\
   0 & 0 & z & 0\\\\
   0 & 0 & 0 & 1
  \end{matrix}
  \right\} 
$$
R = $$
 \left\{
 \begin{matrix}
   1 & 0 & 0 & 0\\\\
   0 & cosθ & -sinθ & 0\\\\
   0 & sinθ & cosθ & 0\\\\
   0 & 0 & 0 & 1
  \end{matrix}
  \right\} 
$$
上述三种变换都是由变换矩阵**左乘**原矩阵
14. Shear 错切
sh<sub>x</sub> = tanθ, 即 y = 1 在 x 方向的距离。
$$
 \left\{
 \begin{matrix}
   1 & shx & 0\\\\
   0 & 1 & 0\\\\
   0 & 0 & 1\\\\
  \end{matrix}
  \right\} 
$$
# 第四章
15. 两种投影的view volume计算
- 透视投影：
x = ± (right - left) / (-2 * near)
y = ± (top - bottom) / (-2 * near)
z<sub>min</sub> = -near
z<sub>max</sub> = -far
- 正交投影
x = left
x = right
y = top 
y = bottom
z<sub>min</sub> = -near
z<sub>max</sub> = -far
16. **Modelview Duality**
可以通过移动viewer或model达到同样的效果，两者的变换矩阵互为逆矩阵。
**移动viewer**: LookAt(eye,at,up)
先用 eye 与 at 算出 z 轴，再用up 和 z 轴算出 x 轴，然后用 z 轴和 x 轴算出 y 轴，最后将坐标轴原点平移到 eye 处。
**移动model**: 
translatef(), rotatef(), scalef()三个函数
17. Viewport 视口
窗口中的画图区，默认大小为整个窗口。
视口可以有一个，也可以有多个
Window2Viewport变换：等同于沿一个固定点作scale
先将window平移回坐标原点，作scale，再移到viewport位置
如果window和viewport的纵横比不一样，作scale式会导致变形，此时应该将缩放系数统一为S<sub>x</sub>, S<sub>y</sub>中两者较小的一个，空出的部分用背景色填充。
18. Viewing Transformations
Viewing：确定摄像机位置和方向
Modeling：在场景中移动模型
Modelview：描述modelview duality
Projection：将3D模型投影到2D窗口
Viewport：将窗口坐标转换到视口坐标
# 第五章 光照与阴影
19. Lighting model （应该不考吧）
Local lighting model: 全部光来自场景内定义的光源。
Global lighting model: 所有表面反射的光会影响到其它表面。
20. **光的组成**
- Ambient 环境光
A  = L<sub>0</sub> + Σ<sub>light</sub>( L<sub>A</sub> * C<sub>A</sub>)
其中L<sub>0</sub>为整体光亮度，L<sub>A</sub>为环境光亮度，C<sub>A</sub>为材质。
**不关心光源位置、观察者位置和表面法向量等。**
- Diffuse 漫反射
D = Σ<sub>lights</sub> L<sub>D</sub> * C<sub>D</sub> * （L · N）
**与物体表面法向量与光向量的夹角有关**
- Specular 镜面反射
S = Σ<sub>lights</sub> L<sub>D</sub> * C<sub>D</sub> * （V · R）<sup>K</sup>
**与眼睛向量与反射光向量的夹角有关**
K 是一个经验常量，数值越大，光斑越小越亮。
21. 计算光照所需要的向量
- 入射光向量
- 反射光向量
- **法向量**
顶点的法向量可以由顶点处的两个向量叉乘求得。
平面的法向量可由组成平面的各个顶点的求平均值得到。
- 眼睛向量
22. 材质
由三个三元组组成，分别表示三种光的RGB值。
23. 光源
- 点光源 (x, y, z, 1)<sup>T</sup>
在同一平面的不同位置，光的方向不同，但法向量相同。
- 平行光 (x, y, z, 0)<sup>T</sup>
在同一平面的不同位置，光的方向相同，法向量也相同。
- 聚光灯 spotlight
包括方向、角度、位置、距离等参数。
24. Light Attenuation 光的衰减
理论值：1 / d²
实际使用：1 / (a + bd + cd²)
25. Shading 计算物体每个像素的颜色
- Constant (Flat) Shading 
根据**一个顶点**计算整个多边形的颜色。
- Gouraud (Smooth) Shading
利用每个顶点的法向量计算顶点的颜色，利用中间插值计算其它点的**颜色**
Increment Computing *作业题*
I<sub>P2</sub> = (1 - t<sub>2</sub>) * I<sub>Q</sub> + t<sub>2</sub> * I<sub>R</sub>
I<sub>P1</sub> = (1 - t<sub>1</sub>) * I<sub>Q</sub> + t<sub>1</sub> * I<sub>R</sub>
I<sub>P2</sub> = I<sub>P1</sub> + (I<sub>R</sub> - I<sub>Q</sub>) (t<sub>2</sub> - t<sub>1</sub>) = I<sub>P1</sub> + ΔI<sub>RQ</sub> * Δt
- Phong Shading
插值获得每个像素对应的**法向量**，并利用这些法向量计算颜色。
Increment Computing 与 Gouraud 类似。
26. 
光(LR, LG, LB)与材质(MR, MG, MB)作用 => (LR*MR, LG*MG, LB*MB)   **相乘**
两个光 (R1, G1, B1) 与 (R2, G2, B2)的叠加 => (R1+R2, G1+G2, B1+B2). **相加**
**漫反射**提供了大部分物体的曲率和深度信息
环境光反射率一般与漫反射率相同
27.Transparency
由RGBA的最后一位——Alpha通道确定（1为不透明，0为完全透明）